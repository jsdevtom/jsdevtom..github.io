<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>toms.blog</title>
  
  <subtitle>Programming Articles</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://toms.blog/"/>
  <updated>2017-12-27T04:21:29.405Z</updated>
  <id>https://toms.blog/</id>
  
  <author>
    <name>Tom (jsdevtom)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Auto Unsubscribing in Angular</title>
    <link href="https://toms.blog/auto-unsubscribing-in-angular/"/>
    <id>https://toms.blog/auto-unsubscribing-in-angular/</id>
    <published>2017-11-22T22:40:40.000Z</published>
    <updated>2017-12-27T04:21:29.405Z</updated>
    
    <content type="html"><![CDATA[<p>In RxJs, <code>Subscription</code>s are objects that listen to a stream (<code>Observable</code>). That‚Äôs it. But there is a catch. If your <code>Subscription</code> is subscribed to an observable, you will need to unsubscribe when the context you are inside is removed. For example, in angular, if you don‚Äôt unsubscribe from a stream inside a component when the component is destroyed, you will be blessed with a memory leak. Which you will first discover after something goes wrong in your application or your app is slow.</p><p>There are multiple ways to manage unsubscription from an observable in Angular. There are pros and cons to each method. In this article we will look at the methods mentioned in various Stack Overflow and blog posts as well as libraries sprinkled across the internet.</p><div class="toc"><!-- toc --><ul><li><a href="#1-storing-the-subscriptions-in-an-array">1. Storing the subscriptions in an array</a></li><li><a href="#2-using-takeuntil">2. Using <code>takeUntil()</code></a></li><li><a href="#3-use-a-custom-rxjs-55-operator">3. Use a custom RxJs 5.5+ operator</a></li><li><a href="#4-use-a-custom-rxjs-55-operator-from-a-library">4. Use a custom RxJs 5.5+ operator from a library</a></li><li><a href="#conclusion">Conclusion</a></li></ul><!-- tocstop --></div><h3><span id="1-storing-the-subscriptions-in-an-array">1. Storing the subscriptions in an array</span></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>({</div><div class="line">    ...</div><div class="line">})</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent <span class="keyword">implements</span> OnInit, OnDestroy {</div><div class="line">    </div><div class="line">    <span class="comment">// store all of the subscriptions created in the component</span></div><div class="line">    <span class="keyword">private</span> subscriptions: <span class="built_in">Array</span><subscription></subscription></div><div class="line">    </div><div class="line">    <span class="comment">// inject some kind of service</span></div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> randomService: RandomService</span>) {}</div><div class="line">    </div><div class="line">    ngOnInit() {</div><div class="line">        <span class="keyword">this</span>.subscriptions.push(</div><div class="line">            <span class="comment">// subscribe returns a Subscription</span></div><div class="line">            <span class="keyword">this</span>.randomService.getObs().subscribe(<span class="function"><span class="params">value</span> =></span> {</div><div class="line">                <span class="comment">// do something with value</span></div><div class="line">            })</div><div class="line">        )</div><div class="line">    }</div><div class="line">    </div><div class="line">    ngOnDestroy () {</div><div class="line">        <span class="comment">// Iterate over all of the subscriptions and unsubscribe from every one</span></div><div class="line">        <span class="keyword">this</span>.subscriptions.forEach(<span class="function"><span class="params">subscription</span> =></span> subscription.unsubscribe())</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure><h4><span id="pros">Pros</span></h4><ul><li>Very easy to understand what is happening</li></ul><h4><span id="cons">Cons</span></h4><ul><li>You have to set <code>private subscriptions: Array<subscription></subscription></code></li><li>You have to implement <code>OnDestroy</code> and iterate over every subscription</li><li>Wrap every subscription</li></ul><h3><span id="2-using-takeuntil">2. Using <code>takeUntil()</code></span></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>({</div><div class="line">    ...</div><div class="line">})</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent <span class="keyword">implements</span> OnInit, OnDestroy {</div><div class="line">    </div><div class="line">    <span class="comment">// create a new Subject which we will emit later</span></div><div class="line">    <span class="comment">// '$' suffix is used to indicate that the variable is an Observable.</span></div><div class="line">    <span class="keyword">private</span> destroy$: Subject<<span class="built_in">void</span>> = <span class="keyword">new</span> Subject<<span class="built_in">void</span>>()</div><div class="line">    </div><div class="line">    <span class="comment">// inject some kind of service</span></div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> randomService: RandomService</span>) {}</div><div class="line">    </div><div class="line">    ngOnInit() {</div><div class="line">        <span class="keyword">this</span>.randomService</div><div class="line">            .getObs() <span class="comment">// get some kind of observable</span></div><div class="line">            .takeUntil(<span class="keyword">this</span>.destroy$) <span class="comment">// kill subscription when `destroy$` emits.</span></div><div class="line">            .subscribe(<span class="function"><span class="params">value</span> =></span> {</div><div class="line">                <span class="comment">// do something with value</span></div><div class="line">            })</div><div class="line">    }</div><div class="line">    </div><div class="line">    ngOnDestroy () {</div><div class="line">        <span class="keyword">this</span>.destroy$.next() <span class="comment">// emit </span></div><div class="line">        <span class="keyword">this</span>.destroy$.complete() <span class="comment">// notify the destroy$'s observer(s) that the destroy$ has finished</span></div><div class="line">                                 <span class="comment">// this is good practice in case there is an other observable</span></div><div class="line">                                 <span class="comment">// that has an onComplete listener.</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure><h4><span id="pros">Pros</span></h4><ul><li>Declarative</li></ul><h4><span id="cons">Cons</span></h4><ul><li>You have to set <code>private destroy$: Subject<void> = new Subject()</void></code></li><li>You have to implement <code>OnDestroy</code> and emit</li><li>If you aren‚Äôt too familiar with RxJs, it is not very intuitive to understand how this is working</li></ul><h3><span id="3-use-a-custom-rxjs-55-operator">3. Use a custom RxJs 5.5+ operator</span></h3><p>In version 5.5 the RxJs team introduced <strong>‚Äúlettable operators‚Äù</strong>, which allow developers to create their own operators without having to attach their function to <code>Observable.prototype</code> or create a pull request. Why <em>lettable</em>? The explanation on RxJs‚Äôs Github page didn‚Äôt make any sense to me but at least they provided its concrete definition:</p><blockquote><p>A function that returns a function with the signature:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag"><<span class="name">T,</span> <span class="attr">R</span>></span>(source: Observable<span class="tag"><<span class="name">T</span>></span>) => Observable<span class="tag"><<span class="name">R</span>></span></div></pre></td></tr></table></figure></p></blockquote><p>If you‚Äôre thinking, just show me the code as I would be right about now, here it is:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> takeUntilDestroy = <span class="function">(<span class="params">target: <span class="built_in">Object</span></span>) =></span> <t><span class="function">(<span class="params">stream: Observable<t></t></span>) =></span> {</t></div><div class="line">  <span class="comment">// get the prototype of the component instance</span></div><div class="line">  <span class="keyword">const</span> targetPrototype = <span class="built_in">Object</span>.getPrototypeOf(target)</div><div class="line">  </div><div class="line">  <span class="comment">// save the reference to the original ngOnDestroy method</span></div><div class="line">  <span class="keyword">const</span> originalDestroy = targetPrototype.ngOnDestroy</div><div class="line"></div><div class="line">  <span class="comment">// check if the component was declared with ngOnDestroy</span></div><div class="line">  <span class="keyword">if</span> (!(originalDestroy && <span class="keyword">typeof</span> originalDestroy === <span class="string">'function'</span>)) {</div><div class="line">      <span class="comment">// read the following error</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"The component was declared without an ngOnDestroy method. This is a problem because Angular will only call the ngOnDestroy method on those components that were initially declared with one."</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> destroy$ = <span class="keyword">new</span> Subject<<span class="literal">null</span>>()</div><div class="line"></div><div class="line">  <span class="comment">// wrap the original ngOnDestroy and emit destroy$</span></div><div class="line">  targetPrototype.ngOnDestroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</div><div class="line">    originalDestroy.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line"></div><div class="line">    destroy$.next()</div><div class="line">    destroy$.complete()</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// return a stream the will be stopped when destroy$ is emitted</span></div><div class="line">  <span class="keyword">return</span> stream.pipe(takeUntil(destroy$))</div><div class="line">}</div></pre></td></tr></table></figure><p>If that was a bit too much, allow me to break it down: what we are doing above is overwriting the component‚Äôs <code>ngOnDestroy</code> method so that when Angular calls <code>ngOnDestroy</code>, it will actually be calling our version. Our version does two things:</p><blockquote><p>a) calls the original <code>ngOnDestroy</code>.<br>b) emits an event that tells the RxJs stream that our method is piped into that no more values are coming after it.</p></blockquote><p>Below you can see that it works with multiple subscriptions and also that not unsubscribing causes memory leaks:</p><iframe class="stackblitz" src="https://stackblitz.com/edit/autounsubscribe?ctl=1&embed=1&file=app/child-with-auto-unsubscribe/child-with-auto-unsubscribe.component.ts"><br></iframe><h4><span id="pros">Pros</span></h4><ul><li>Once written, it is a lot less code, namely one per subscription</li><li>Your components can worry about their (hopefully) single responsibility and not unsubscribing (as much)</li></ul><h4><span id="cons">Cons</span></h4><ul><li>A new <code>destroy$</code> will be created for each stream (we will fix this next)</li><li>Uses magic</li></ul><h3><span id="4-use-a-custom-rxjs-55-operator-from-a-library">4. Use a custom RxJs 5.5+ operator from a library</span></h3><p>Disclaimer: I wrote this library üòÖ. It uses a <code>WeakMap</code> to store the class instance with the relevant <code>destroy$</code> Subject so that unnecessary Subjects are‚Äônt created every time you call <code>takeUntilDestroy(this)</code>. You can find the <a href="https://github.com/jsdevtom/take-until-destroy/blob/master/src/take-until-destroy.ts" target="_blank" rel="external">implementation here</a>. </p><p>Here is how you use it:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> { Destroyable, takeUntilDestroy } <span class="keyword">from</span> <span class="string">'take-until-destroy'</span></div><div class="line"></div><div class="line"><span class="comment">// If you have already implemented `OnDestroy`, you don't</span></div><div class="line"><span class="comment">// need the `@Destroyable` decorator.</span></div><div class="line"><span class="meta">@Destroyable</span></div><div class="line"><span class="meta">@Component</span>({</div><div class="line">  ...</div><div class="line">})</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent {</div><div class="line">   <span class="keyword">constructor</span>(<span class="params">randomService: RandomService</span>) {</div><div class="line">       randomService.getObservable</div><div class="line">           .pipe(takeUntilDestroy(<span class="keyword">this</span>))</div><div class="line">           .subscribe(<span class="function"><span class="params">v</span> =></span> {</div><div class="line">               <span class="built_in">console</span>.log(v)</div><div class="line">           })</div><div class="line">   }</div><div class="line">}</div></pre></td></tr></table></figure><p>What is <code>Destroyable</code>? Remember in that error message above where I mentioned that not declaring <code>ngOnDestroy</code> initially is a problem because Angular will only call the <code>ngOnDestroy</code> method on those components that were initially declared with one? It just declares one if there isn‚Äôt one already.</p><h4><span id="pros">Pros</span></h4><ul><li>It is already written, tested and optimized</li><li>It is a lot less code, namely one per subscription</li><li>Your components can worry about their (hopefully) single responsibility and not unsubscribing (as much)</li></ul><h4><span id="cons">Cons</span></h4><ul><li>Uses magic</li><li>Another dependency</li></ul><h3><span id="conclusion">Conclusion</span></h3><p>Obviously I am biased towards the small npm package that I authored. It is small, less code and tested to a high standard. Please bear in mind that the library is only meant for Angular 5+ because in this version it updates its dependency of RxJs to 5.5 starting from which <code>lettable</code> operators are available.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In RxJs, &lt;code&gt;Subscription&lt;/code&gt;s are objects that listen to a stream (&lt;code&gt;Observable&lt;/code&gt;). That‚Äôs it. But there is a catch. If yo
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://toms.blog/categories/javascript/"/>
    
    
      <category term="Angular" scheme="https://toms.blog/tags/angular/"/>
    
      <category term="RxJs" scheme="https://toms.blog/tags/rxjs/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://toms.blog/hello-world/"/>
    <id>https://toms.blog/hello-world/</id>
    <published>2017-11-18T08:39:07.624Z</published>
    <updated>2017-11-18T08:39:07.620Z</updated>
    
    <content type="html"><![CDATA[<p>So I‚Äôve decided to become a blogger. Why? I want to </p><ul><li>Share the knowledge that my team and I struggle to find</li><li>Reinforce the things that I learn by teaching them</li><li>I bought this fairly expensive domain name and I am determined to use it</li></ul><p></p><h5 class="table-of-contents-header"><span id="table-of-contents">Table of contents</span></h5><p></p><div class="toc"><!-- toc --><ul><li><a href="#who-are-you">Who are you?</a></li><li><a href="#what-are-you-going-to-be-writing-about">What are you going to be writing about?</a></li><li><a href="#how-often-will-you-be-posting">How often will you be posting?</a></li><li><a href="#who-are-you-writing-for">Who Are You Writing For?</a></li><li><a href="#how-can-i-get-involved">How can I get involved?</a></li></ul><!-- tocstop --></div><h2><span id="who-are-you">Who are you?</span></h2><p>I am a young, untraditionally taught programmer who works for a startup in Munich. My team and I use typescript and angular daily although my interests also lie in artificial intelligence.</p><p>On a more personal level, I have been very lucky to have had a great upbringing and also to have discovered self-improvement. Self-improvement has, after the two years that I have been actively pursuing it, helped me to get start a programming career with 0 experience, get well on the way to my physical goals and develop a strong mental state among other things.</p><h2><span id="what-are-you-going-to-be-writing-about">What are you going to be writing about?</span></h2><p>I plan to write about four main topics:</p><ul><li>Angular</li><li>Artificial intelligence</li><li>Rust (I am currently a beginner so bare with me here)</li><li>JavaScript/ TypeScript</li></ul><p>I am going to be including code snippets and live examples whilst trying to keep the posts under a ten-minute read and to the point. A Tl;dr will be included where this is not possible; I know how frustrating it can be to try to get information from some overly long post. </p><p>If you feel that I need to expand on something that I am writing about, feel free to let me know! I love to help.</p><h2><span id="how-often-will-you-be-posting">How often will you be posting?</span></h2><p>Once a week is the goal. Working full time and commuting doesn‚Äôt leave much time left over. As mentioned above, I will be reinforcing what I have learnt by teaching it and I learn quite a bit so hopefully I will be able to post more often. We‚Äôll see.</p><h2><span id="who-are-you-writing-for">Who Are You Writing For?</span></h2><p>People who want to learn to program (better) and/or keep up to date with the latest technological developments in the areas mentioned above. I guess if you are reading this, you probably are a software developer or want to become one. Blog posts were a critical part in achieving my goal of becoming a web developer. I feel that these posts could help you in the same way!</p><h2><span id="how-can-i-get-involved">How can I get involved?</span></h2><p>Comment below the posts, create pull requests on the examples, share the content if you think your circle would also find it useful.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;So I‚Äôve decided to become a blogger. Why? I want to &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Share the knowledge that my team and I struggle to find&lt;/li&gt;
&lt;li&gt;Reinfo
      
    
    </summary>
    
    
      <category term="Introduction" scheme="https://toms.blog/tags/introduction/"/>
    
      <category term="toms.blog" scheme="https://toms.blog/tags/toms-blog/"/>
    
      <category term="About" scheme="https://toms.blog/tags/about/"/>
    
  </entry>
  
</feed>
