<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta charset="UTF-8"><title>Auto Unsubscribing in Angular | toms.blog</title><meta name="author" content="Tom (jsdevtom)"><meta name="description" content="Read articles about Angular, AI, Rust and JavaScript. Updated regularly and straight to the point."><link rel="canonical" href="https://toms.blog/auto-unsubscribing-in-angular/"><link rel="stylesheet" href="/css/normalize.css?__inline=true"><link href="https://fonts.googleapis.com/css?family=Merriweather" rel="stylesheet"><link rel="stylesheet" type="text/css" href="/css/main.css?__inline=true"><link rel="icon" href="/images/favicon_v2.ico"><!-- PWA--><link rel="manifest" href="/manifest.json"><!-- theme-color defines the top bar color--><meta name="theme-color" content="rgb(198, 38, 65)"><!-- Add to home screen for Safari on iOS--><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="apple-mobile-web-app-title" content="toms.blog"><link rel="apple-touch-icon" href="/images/favicon_v2.ico"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Auto Unsubscribing in Angular | toms.blog"><meta property="og:description" content=""><meta property="og:url" content="https://toms.blog/auto-unsubscribing-in-angular/index.html"><meta property="og:site_name" content="toms.blog"><meta property="og:image" content="https://toms.blog/auto-unsubscribing-in-angular/index.html/images/favicon_v2.ico"><meta property="og:image:width" content="256"><meta property="og:image:height" content="256"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Auto Unsubscribing in Angular | toms.blog"><meta name="twitter:description" content=""><meta name="twitter:image" content="https://toms.blog/auto-unsubscribing-in-angular/index.html/images/favicon_v2.ico"></head><body><div class="header"><h1 class="title"><a href="/">toms.blog</a></h1><ul class="category-list"><li class="category-list-item"><a class="category-list-link current" href="/categories/javascript/">JavaScript</a></li></ul></div><div class="red-material"></div><div class="content"><div class="post-item"><h2 class="post-title-wrapper"><p class="post-title">Auto Unsubscribing in Angular</p></h2><div class="post-date"><time datetime="2017-11-22T22:40:40.000Z">2017-11-22</time></div><div class="post-content"><p>There are multiple ways to managed unsubscription from an observable in Angular. There are pros and cons to each method. In this article we will look at the methods mentioned in various Stack Overflow and blog posts as well as libraries sprinkled across the internet.</p>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#1-storing-the-subscriptions-in-an-array">1. Storing the subscriptions in an array</a></li>
<li><a href="#2-using-takeuntil">2. Using <code>takeUntil()</code></a></li>
<li><a href="#3-use-a-custom-rxjs-55-operator">3. Use a custom RxJs 5.5+ operator</a></li>
<li><a href="#4-use-a-custom-rxjs-55-operator-from-a-library">4. Use a custom RxJs 5.5+ operator from a library</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<!-- tocstop -->
</div>

<h3><span id="1-storing-the-subscriptions-in-an-array">1. Storing the subscriptions in an array</span></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>({</div><div class="line">    ...</div><div class="line">})</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent <span class="keyword">implements</span> OnInit, OnDestroy {</div><div class="line">    </div><div class="line">    <span class="comment">// store all of the subscriptions created in the component</span></div><div class="line">    <span class="keyword">private</span> subscriptions: <span class="built_in">Array</span><subscription></subscription></div><div class="line">    </div><div class="line">    <span class="comment">// inject some kind of service</span></div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> randomService: RandomService</span>) {}</div><div class="line">    </div><div class="line">    ngOnInit() {</div><div class="line">        <span class="keyword">this</span>.subscriptions.push(</div><div class="line">            <span class="comment">// subscribe returns a Subscription</span></div><div class="line">            <span class="keyword">this</span>.randomService.getObs().subscribe(<span class="function"><span class="params">value</span> =></span> {</div><div class="line">                <span class="comment">// do something with value</span></div><div class="line">            })</div><div class="line">        )</div><div class="line">    }</div><div class="line">    </div><div class="line">    ngOnDestroy () {</div><div class="line">        <span class="comment">// Iterate over all of the subscriptions and unsubscribe from every one</span></div><div class="line">        <span class="keyword">this</span>.subscriptions.forEach(<span class="function"><span class="params">subscription</span> =></span> subscription.unsubscribe())</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>
<h4><span id="pros">Pros</span></h4><ul>
<li>Very easy to understand what is happening</li>
</ul>
<h4><span id="cons">Cons</span></h4><ul>
<li>You have to set <code>private subscriptions: Array<subscription></subscription></code></li>
<li>You have to implement <code>OnDestroy</code> and iterate over every subscription</li>
<li>Wrap every subscription</li>
</ul>
<h3><span id="2-using-takeuntil">2. Using <code>takeUntil()</code></span></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>({</div><div class="line">    ...</div><div class="line">})</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent <span class="keyword">implements</span> OnInit, OnDestroy {</div><div class="line">    </div><div class="line">    <span class="comment">// create a new Subject which we will emit later</span></div><div class="line">    <span class="keyword">private</span> destroy$: Subject<<span class="built_in">void</span>> = <span class="keyword">new</span> Subject()</div><div class="line">    </div><div class="line">    <span class="comment">// inject some kind of service</span></div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> randomService: RandomService</span>) {}</div><div class="line">    </div><div class="line">    ngOnInit() {</div><div class="line">        <span class="keyword">this</span>.randomService</div><div class="line">            .getObs() <span class="comment">// get some kind of observable</span></div><div class="line">            .takeUntil(<span class="keyword">this</span>.destroy$) <span class="comment">// kill subscription when `destroy$` emits.</span></div><div class="line">            .subscribe(<span class="function"><span class="params">value</span> =></span> {</div><div class="line">                <span class="comment">// do something with value</span></div><div class="line">            })</div><div class="line">    }</div><div class="line">    </div><div class="line">    ngOnDestroy () {</div><div class="line">        <span class="keyword">this</span>.destroy$.next() <span class="comment">// emit </span></div><div class="line">        <span class="keyword">this</span>.destroy$.complete() <span class="comment">// notify the destroy$'s observer(s) that the destroy$ has finished</span></div><div class="line">                                 <span class="comment">// this is good practice in case there is an other observable</span></div><div class="line">                                 <span class="comment">// that has an onComplete listener.</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>
<h4><span id="pros">Pros</span></h4><ul>
<li>Declarative</li>
</ul>
<h4><span id="cons">Cons</span></h4><ul>
<li>You have to set <code>private destroy$: Subject<void> = new Subject()</void></code></li>
<li>You have to implement <code>OnDestroy</code> and emit</li>
<li>If you aren‚Äôt too familiar with RxJs, it is not very intuitive to understand how this is working</li>
</ul>
<h3><span id="3-use-a-custom-rxjs-55-operator">3. Use a custom RxJs 5.5+ operator</span></h3><p>In version 5.5 the RxJs team introduced <strong>‚Äúlettable operators‚Äù</strong>, which allow developers to create their own operators without having to attach their function to <code>Observable.prototype</code> or create a pull request. Why <em>lettable</em>? The explanation on RxJs‚Äôs Github page didn‚Äôt make any sense to me but at least they provided its concrete definition:</p>
<blockquote>
<p>A function that returns a function with the signature:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag"><<span class="name">T,</span> <span class="attr">R</span>></span>(source: Observable<span class="tag"><<span class="name">T</span>></span>) => Observable<span class="tag"><<span class="name">R</span>></span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>If you‚Äôre thinking, just show me the code like I would be right about now, here it is:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> takeUntilDestroy = <span class="function">(<span class="params">target: <span class="built_in">Object</span></span>) =></span> <t><span class="function">(<span class="params">stream: Observable<t></t></span>) =></span> {</t></div><div class="line">  <span class="comment">// get the prototype of the component instance</span></div><div class="line">  <span class="keyword">const</span> targetPrototype = <span class="built_in">Object</span>.getPrototypeOf(target)</div><div class="line">  </div><div class="line">  <span class="comment">// save the reference to the original ngOnDestroy method</span></div><div class="line">  <span class="keyword">const</span> originalDestroy = targetPrototype.ngOnDestroy</div><div class="line"></div><div class="line">  <span class="comment">// check if the component was declared with ngOnDestroy</span></div><div class="line">  <span class="keyword">if</span> (!(originalDestroy && <span class="keyword">typeof</span> originalDestroy === <span class="string">'function'</span>)) {</div><div class="line">      <span class="comment">// read the following error</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"The component was declared without an ngOnDestroy method. This is a problem because Angular will only call the ngOnDestroy method on those components that were initially declared with one."</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> destroy$ = <span class="keyword">new</span> Subject<<span class="literal">null</span>>()</div><div class="line"></div><div class="line">  <span class="comment">// wrap the original ngOnDestroy and emit destroy$</span></div><div class="line">  targetPrototype.ngOnDestroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</div><div class="line">    originalDestroy.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line"></div><div class="line">    destroy$.next()</div><div class="line">    destroy$.complete()</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// return a stream the will be stopped when destroy$ is emitted</span></div><div class="line">  <span class="keyword">return</span> stream.pipe(takeUntil(destroy$))</div><div class="line">}</div></pre></td></tr></table></figure>
<p>If that was a bit too much, allow me to break it down: what we are doing above is overwriting the component‚Äôs <code>ngOnDestroy</code> method so that when Angular calls <code>ngOnDestroy</code>, it will actually be calling our version. Our version does two things:</p>
<blockquote>
<p>a) calls the original <code>ngOnDestroy</code>.<br>b) emits an event that tells the RxJs stream that our method is piped into that no more values are coming after it.</p>
</blockquote>
<p>Below you can see that it works with multiple subscriptions and also that not unsubscribing causes memory leaks:</p>
<iframe class="stackblitz" src="https://stackblitz.com/edit/autounsubscribe?ctl=1&embed=1&file=app/child-with-auto-unsubscribe/child-with-auto-unsubscribe.component.ts"><br></iframe>

<h4><span id="pros">Pros</span></h4><ul>
<li>Once written, it is a lot less code, namely one per subscription</li>
<li>Your components can worry about their (hopefully) single responsibility and not unsubscribing (as much)</li>
</ul>
<h4><span id="cons">Cons</span></h4><ul>
<li>A new <code>destroy$</code> will be created for each stream (we will fix this next)</li>
<li>Uses magic</li>
</ul>
<h3><span id="4-use-a-custom-rxjs-55-operator-from-a-library">4. Use a custom RxJs 5.5+ operator from a library</span></h3><p>Disclaimer: I wrote this library üòÖ. It uses a <code>WeakMap</code> to store the class instance with the relevant <code>destroy$</code> Subject so that unnecessary Subject‚Äôs are‚Äônt created every time you call <code>takeUntilDestroy(this)</code>. You can find the <a href="https://github.com/jsdevtom/take-until-destroy/blob/master/src/take-until-destroy.ts" target="_blank" rel="external">implementation here</a>. </p>
<p>Here is how you use it:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> { Destroyable, takeUntilDestroy } <span class="keyword">from</span> <span class="string">'take-until-destroy'</span></div><div class="line"></div><div class="line"><span class="comment">// If you have already implemented `OnDestroy`, you don't</span></div><div class="line"><span class="comment">// need the `@Destroyable` decorator.</span></div><div class="line"><span class="meta">@Destroyable</span></div><div class="line"><span class="meta">@Component</span>({</div><div class="line">  ...</div><div class="line">})</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> ExampleComponent {</div><div class="line">   <span class="keyword">constructor</span>(<span class="params">randomService: RandomService</span>) {</div><div class="line">       randomService.getObservable</div><div class="line">           .pipe(takeUntilDestroy(<span class="keyword">this</span>))</div><div class="line">           .subscribe(<span class="function"><span class="params">v</span> =></span> {</div><div class="line">               <span class="built_in">console</span>.log(v)</div><div class="line">           })</div><div class="line">   }</div><div class="line">}</div></pre></td></tr></table></figure>
<p>What is <code>Destroyable</code>? Remember in that error message above where I mentioned that not declaring <code>ngOnDestroy</code> initially is a problem because Angular will only call the <code>ngOnDestroy</code> method on those components that were initially declared with one? It just declares one if there isn‚Äôt one already.</p>
<h4><span id="pros">Pros</span></h4><ul>
<li>It is already written, tested and optimized</li>
<li>It is a lot less code, namely one per subscription</li>
<li>Your components can worry about their (hopefully) single responsibility and not unsubscribing (as much)</li>
</ul>
<h4><span id="cons">Cons</span></h4><ul>
<li>Uses magic</li>
<li>Another dependency</li>
</ul>
<h3><span id="conclusion">Conclusion</span></h3><p>Obviously I am biased towards the small npm package that I authored. It is small, less code and tested to a high standard. Please bear in mind that the library is only meant for Angular 5+ because in this version it updates its dependency of RxJs to 5.5 starting from which <code>lettable</code> operators are available.</p>
</div><div class="disqus"><div id="disqus_thread"></div><script>const disqus_config = function () {
    this.page.url = page.permalink;
    this.page.identifier = config.disqus_shortname;
};
(function () {
    var d = document, s = d.createElement('script');
    s.src = 'https://tom-s-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();</script></div></div></div><div class="footer"><a href="https://github.com/jsdevtom" target="_blank" rel="noopener"><img class="icon-links" src="/images/icons/github.svg" alt="Tom on GitHub"></a><a href="https://stackoverflow.com/users/5950725/tom" target="_blank" rel="noopener"><img class="icon-links" src="/images/icons/stack-overflow.svg" alt="Tom on Stack Overflow"></a><a href="https://jsdevtom.com" target="_blank" rel="noopener"><img class="icon-links" src="/images/icons/globe.svg" alt="Tom's Website"></a></div><script async defer src="/js/scrollFade.js"></script></body></html>